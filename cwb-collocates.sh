#!/usr/bin/env bash

# {{{ Usage
usage () {
cat <<-END
DESCRIPTION:
    Wrapper around CQP tabulate and cwb-scan-corpus to create
    frequency tables of collocates.

    (c) 2021 Alexander Rauhut, GNU General Public License 3.0.

USAGE:
    [<stdin>] $0 [-f|--file filename]
    [-c|--case-insensitive] [-r|--range <int>]
    corpus ?query [attr="word"]

    Required input is pairs of integer values that indicate corpus positions
    for cwb-scan-corpus -R to scan; see "man cwb-scan-corpus". Alternatively,
    the required data can be generated by providing a CQP query.

    -c|--case)  produce case-insensitive counts
    -m|--match) include match frequency; see CQP count
    -r|--range) specify scan range; default=4
    -f|--file)  provide a file with pairs of corpus positions for the match range
                e.g. from CQP "tabulate match, matchend"
    -h|--help)  display this help message
END
}

# }}} ------------------------------------------------------------------------
# {{{ Options, defaults, and argument parsing

# "strict mode"
set -euo pipefail
set -o noclobber
# IFS=$'\n\t'

range=4

abs_path() { echo "$(cd "$(dirname "$1")" && pwd)/$(basename "$1")" ; }

stop_if_missing() {
  if [ -z "$1" ]; then
    echo "$2"; exit 1
  fi
}

while [ $# -gt 0 ]; do
  case "$1" in
    -c|--case)  case="c"; shift ;;
    -m|--match) match=true; shift ;;
    -r|--range) range=$2; shift; shift ;;
    -f|--file)  file="$(abs_path $2)"; shift; shift ;;
    -h|--help)  usage; exit 0 ;;
    *) break ;;
  esac
done

corpus=${1:-}
attr="${2:-word}"

stop_if_missing "${corpus}" "No corpus name supplied. See $0 --help."

# }}} ------------------------------------------------------------------------
# {{{ Preparing data

# creating temporary folder to buffer files; make sure it's deleted on exit
tmp="$(mktemp -d)"
trap 'rm -rf -- "$tmp"' EXIT
cd "$tmp"

# query for corpus positions of matches if not provided
query() {
  cqp_cmd="tabulate Last match, matchend"
  echo "${corpus}; ${query}; ${cqp_cmd} > \"${data}\";" | cqp -c 2>/dev/null
}

match_cmd="count by ${attr}"
[ "${case:-}" ] && match_cmd="count by ${attr}\%c"

# set data to filename or create unambiguous temporary filename
[ "${file:-}" ] && data="${file:-}" || data=".${0##*/}-$$"

# if stdin, buffer file; if neither stdin nor -f, create file with query
if [ -p /dev/stdin ]; then
  cat /dev/stdin > "$data"
elif [ ! "${file:-}" ]; then
  query="${2:-}"
  attr="${3:-word}"
  stop_if_missing "$query" "No file or query supplied. See $0 --help."
  query
fi

# }}} ------------------------------------------------------------------------
# {{{ Helper functions

# use CQP count to count matches at positions
count_match() {
  count_cmd="count by ${attr};"
  [ ${case:-} ] && case_cmd='%c'

  echo "set PrettyPrint off;
  ${corpus}; undump Last < \"${data}\";
  count by ${attr} ${case_cmd:-};" | cqp -c | cut -f2 --complement | sed '1d'
}

# scan frequencies at offset positions
scan() { cwb-scan-corpus -q -R - "${corpus}" "${attr}" ; }

# -c; make counts case insensitive
fold() {
  awk 'BEGIN { OFS="\t" } { a[tolower($2)] += $1 }
       END { for (i in a) print a[i], i }'
}

if [ ${case:-} ]; then
  count() { scan | fold ; }
else
  count() { scan ; }
fi

# calculate left and right offset positions; remove out-of-range positions
# $1 = iterator; $2 = file; inner { $1 = match; $2 = matchend }
offset_left()  { awk -v i=$1 '{ print $1-i, $1-i }' $2 | sed '/^-/d' ; }
offset_right() { awk -v i=$1 '{ print $2+i, $2+i }' $2 ; }

# }}} ------------------------------------------------------------------------
# {{{ Main

main() {
  # get frequencies for every position
  [ "${match:-}" ] && count_match > right0 &

  for ((i=1; i<=range; i++)); do
    offset_left  $i "${data}" | count | sort -nr -k1 > left$i &
    offset_right $i "${data}" | count | sort -nr -k1 > right$i 2>/dev/null &
  done
  wait

  # join files and pad gaps due to different lengths
  # tac reverses left files to get correct kwic-like ordering after globbing
  paste $(echo left* | tac -s ' ') right* \
    | sed "s/\t\t/\t\t\t/g" | sed "s/^\t/\t\t/g"
}

main

# }}} ------------------------------------------------------------------------
# {{{ Notes
#
# It would be convenient to be able to infer the corpus used and omit the
# argument. As of cwb 3.0.0, I don't know an easy fix for this. Later versions
# might work with `cat` or `show active`. Here is a dirty hack:
#
# # inject into this script:
#
# if [ -f "/tmp/corpus" ]; then
#   corpus=${1:-$(cat /tmp/corpus_name)};
#   [ $# -gt 0 ] && shift
# fi
#
# # use with cqp macro:
#
# MACRO collocates(0)
# tabulate Last match, matchend;
# ""; set po hdr;
# cat Last > '| grep "Query" | cut -f3 -d " " | tr -d ";" > "corpus_name"'
# ;
#
# }}} ------------------------------------------------------------------------
# {{{ License
#
# CWB wrapper to create frequency tables of collocates
# Copyright (C) 2020 Alexander Rauhut
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# }}} -------------------------------------------------------------------------
